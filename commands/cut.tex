\SACCMD{cut}
\label{cmd:cut}

\SACTitle{概要}
定义要读入的数据窗

\SACTitle{语法}
\begin{SACSTX}
CUT [ON|OFF|pdw|SIGNAL]
\end{SACSTX}

\SACTitle{输入}
\begin{description}
\item [pdw] 打开截窗选项并修改 \nameref{subsec:pdw}
\item [ON] 打开截窗选项但不改变 \texttt{pdw}
\item [OFF] 关闭截窗选项
\item [SIGNAL] 等效于设置 \texttt{pdw} 为 \texttt{A -1 F 1}，即 \texttt{a}
    前一秒到 \texttt{f} 后一秒的数据窗
\end{description}

\SACTitle{缺省值}
\begin{SACDFT}
cut off
\end{SACDFT}

\SACTitle{说明}
\texttt{cut} 命令仅仅设置了要读取的时间窗选项，并不对内存中的数据进行截取。
因而，若要该命令起作用，需要在 \texttt{cut} 命令设置时间窗后使用
\texttt{read}命令。与此相反，\nameref{cmd:cutim} 命令会在命令执行时直接
对内存中的数据进行截取。

若截窗选项为关，则读取整个文件；若截窗选项为开，则只读取由 \texttt{pdw}
定义的部分。

如果你想对一组有不同参考时刻的文件使用同样的时间窗，必须在执行 \texttt{cut}
前先使用 \nameref{cmd:synchronize} 命令使所有文件具有相同的参考时刻。
\texttt{synchronize} 命令修改了文件的头段使得所有文件具有相同的参考时刻，
并调整所有相对时间。因而，你需要先读取所有文件，执行 \texttt{synchronize}
命令，使用 \nameref{cmd:writehdr} 将修改后的头段写入到磁盘文件中，然后
再执行 \texttt{cut} 命令，并读取数据，这样才能得到正确的结果。

\SACTitle{示例}
下面的宏文件展示了 \texttt{cut} 命令的一些常见用法。
\begin{SACCode}
fg seismo
wrie seismo.sac
echo on
* no cutting
lh b e a kztime
read seismo.sac
* begin to end---same as not cutting.
cut B E
read
lh b e a kztime
read seismo.sac
* First 3 secs of the file
cut B 0 3
read
lh b e a kztime
read seismo.sac
* First 100 points of the file.
cut B N 100
read
lh b e a delta kztime
read seismo.sac
* From 0.5 secs before to 3 secs after first arrival
cut A -0.5 3
read
lh b e a kztime
read seismo.sac
* From 19 to 15 secs relative to zero (DIFFERENT FROM CUTIM).
cut 10 15
read
lh b e a kztime
read seismo.sac
* First 3 secs of the file and next 3 sec
cut b 0 3
read
write tmp.1
read seismo.sac
cut b 3 6
read
write tmp.2
cut off
read tmp.?
lh b e a kztime
p1
\end{SACCode}

当要截取的窗超过了文件的时间范围时，可以使用 \nameref{cmd:cuterr} 命令的
\texttt{FILLZ} 选项，在文件的开始或结尾处补0，再读入内存。
\begin{SACCode}
SAC> r N11A.lhz
SAC> lh npts
    npts = 3101

SAC> cuterr fillz; cut b n 4096
SAC> r
SAC> lh npts
    npts = 4096
\end{SACCode}

\SACTitle{限制}
目前不支持非等间隔文件或谱文件的截断。该命令对ASCII格式的SAC文件无效。
